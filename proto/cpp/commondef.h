// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.1.0.
// **********************************************************************

#ifndef __COMMONDEF_H_
#define __COMMONDEF_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
using namespace std;


namespace CommonDef
{
    enum EN_PLATFORM
    {
        PLAT_NONE = 0,
        PLAT_WIN = 1,
        PLAT_ANDROID = 2,
        PLAT_MAC = 3,
        PLAT_IOS = 4,
        PLAT_IPAD = 5,
    };
    inline string etos(const EN_PLATFORM & e)
    {
        switch(e)
        {
            case PLAT_NONE: return "PLAT_NONE";
            case PLAT_WIN: return "PLAT_WIN";
            case PLAT_ANDROID: return "PLAT_ANDROID";
            case PLAT_MAC: return "PLAT_MAC";
            case PLAT_IOS: return "PLAT_IOS";
            case PLAT_IPAD: return "PLAT_IPAD";
            default: return "";
        }
    }
    inline int stoe(const string & s, EN_PLATFORM & e)
    {
        if(s == "PLAT_NONE")  { e=PLAT_NONE; return 0;}
        if(s == "PLAT_WIN")  { e=PLAT_WIN; return 0;}
        if(s == "PLAT_ANDROID")  { e=PLAT_ANDROID; return 0;}
        if(s == "PLAT_MAC")  { e=PLAT_MAC; return 0;}
        if(s == "PLAT_IOS")  { e=PLAT_IOS; return 0;}
        if(s == "PLAT_IPAD")  { e=PLAT_IPAD; return 0;}

        return -1;
    }

    enum EN_CLIENT_TYPE
    {
        CLIENT_NONE = 0,
        CLIENT_APP = 1,
        CLIENT_WEB = 2,
        CLIENT_H5 = 3,
        CLIENT_WX_MINI = 4,
    };
    inline string etos(const EN_CLIENT_TYPE & e)
    {
        switch(e)
        {
            case CLIENT_NONE: return "CLIENT_NONE";
            case CLIENT_APP: return "CLIENT_APP";
            case CLIENT_WEB: return "CLIENT_WEB";
            case CLIENT_H5: return "CLIENT_H5";
            case CLIENT_WX_MINI: return "CLIENT_WX_MINI";
            default: return "";
        }
    }
    inline int stoe(const string & s, EN_CLIENT_TYPE & e)
    {
        if(s == "CLIENT_NONE")  { e=CLIENT_NONE; return 0;}
        if(s == "CLIENT_APP")  { e=CLIENT_APP; return 0;}
        if(s == "CLIENT_WEB")  { e=CLIENT_WEB; return 0;}
        if(s == "CLIENT_H5")  { e=CLIENT_H5; return 0;}
        if(s == "CLIENT_WX_MINI")  { e=CLIENT_WX_MINI; return 0;}

        return -1;
    }

    enum EN_USER_TYPE
    {
        USER_NONE = 0,
        USER_UID = 1,
        USER_WX_OPENID = 11,
        USER_WX_UNIONID = 12,
        USER_ALIPAY = 21,
    };
    inline string etos(const EN_USER_TYPE & e)
    {
        switch(e)
        {
            case USER_NONE: return "USER_NONE";
            case USER_UID: return "USER_UID";
            case USER_WX_OPENID: return "USER_WX_OPENID";
            case USER_WX_UNIONID: return "USER_WX_UNIONID";
            case USER_ALIPAY: return "USER_ALIPAY";
            default: return "";
        }
    }
    inline int stoe(const string & s, EN_USER_TYPE & e)
    {
        if(s == "USER_NONE")  { e=USER_NONE; return 0;}
        if(s == "USER_UID")  { e=USER_UID; return 0;}
        if(s == "USER_WX_OPENID")  { e=USER_WX_OPENID; return 0;}
        if(s == "USER_WX_UNIONID")  { e=USER_WX_UNIONID; return 0;}
        if(s == "USER_ALIPAY")  { e=USER_ALIPAY; return 0;}

        return -1;
    }

    struct st_user_info : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "CommonDef.st_user_info";
        }
        static string MD5()
        {
            return "cca41655ef02173a34fb6fd7b66ff38e";
        }
        st_user_info()
        :user_type(0),user_id(""),appid(""),access_token("")
        {
        }
        void resetDefautlt()
        {
            user_type = 0;
            user_id = "";
            appid = "";
            access_token = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(user_type, 0);
            _os.write(user_id, 1);
            _os.write(appid, 2);
            _os.write(access_token, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(user_type, 0, true);
            _is.read(user_id, 1, true);
            _is.read(appid, 2, true);
            _is.read(access_token, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(user_type,"user_type");
            _ds.display(user_id,"user_id");
            _ds.display(appid,"appid");
            _ds.display(access_token,"access_token");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(user_type, true);
            _ds.displaySimple(user_id, true);
            _ds.displaySimple(appid, true);
            _ds.displaySimple(access_token, false);
            return _os;
        }
    public:
        tars::Int32 user_type;
        std::string user_id;
        std::string appid;
        std::string access_token;
    };
    inline bool operator==(const st_user_info&l, const st_user_info&r)
    {
        return l.user_type == r.user_type && l.user_id == r.user_id && l.appid == r.appid && l.access_token == r.access_token;
    }
    inline bool operator!=(const st_user_info&l, const st_user_info&r)
    {
        return !(l == r);
    }

    struct st_page_context : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "CommonDef.st_page_context";
        }
        static string MD5()
        {
            return "aea402d67a51a1314b2b40d2714a382f";
        }
        st_page_context()
        :index(0),total(0),has_next(0)
        {
        }
        void resetDefautlt()
        {
            index = 0;
            total = 0;
            has_next = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(index, 0);
            _os.write(total, 1);
            _os.write(has_next, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(index, 0, true);
            _is.read(total, 1, true);
            _is.read(has_next, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(index,"index");
            _ds.display(total,"total");
            _ds.display(has_next,"has_next");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(index, true);
            _ds.displaySimple(total, true);
            _ds.displaySimple(has_next, false);
            return _os;
        }
    public:
        tars::Int32 index;
        tars::Int32 total;
        tars::Int32 has_next;
    };
    inline bool operator==(const st_page_context&l, const st_page_context&r)
    {
        return l.index == r.index && l.total == r.total && l.has_next == r.has_next;
    }
    inline bool operator!=(const st_page_context&l, const st_page_context&r)
    {
        return !(l == r);
    }


}



#endif
